---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# tidyaml <img src="man/figures/logo.png" width="147" height="170" align="right" />

<!-- badges: start -->
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/tidyaml)](https://cran.r-project.org/package=tidyaml)
![](https://cranlogs.r-pkg.org/badges/tidyaml)
![](https://cranlogs.r-pkg.org/badges/grand-total/tidyaml)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html##experimental)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](https://makeapullrequest.com)
<!-- badges: end -->

## Introduction

The goal of the `{tidyaml}` package is to serve as a sort of __Auto ML__ for the
__`tidymodels`__ ecosystem. Some ideas are that we should be able to generate regression
models on the fly without having to actually go through the process of building the
specification, especially if it is a non-tuning model, meaning we are not planing
on tuning hyper-parameters like `penalty` and `cost`.

The idea is not to re-write the excellent work the `tidymodels` team has done (because
it's not possible) but rather to try and make an enhanced easy to use set of functions
that do what they say and can generate many models and predictions at once.

This is similar to the great `h2o` package, but, `{tidyaml}` does not require java
to be setup properly like `h2o` because `{tidyaml}` is built on `tidymodels`.

## Installation

You can install `{tidyaml}` like so (But neither are available yet)

```{r}
# Not yet on CRAN
# install.packages("tidyaml")
```
Or the development version from GitHub
```{r}
# install.packages("devtools")
# devtools::install_github("spsanderson/TidyDensity")
```

## Examples

Part of the reason to use `{tidyaml}` is so that you can generate many models of
your data set. One way of modeling a data set is using regression for some numeric
output. There is a convienent function in __tidyaml__ that will generate a set of
non-tuning models for _fast regression_. Let's take a look below.

First let's load the library
```{r example}
library(tidyaml)
```

Now lets see the function in action.
```{r}
fast_regression_parsnip_spec_tbl(.parsnip_fns = "linear_reg")
fast_regression_parsnip_spec_tbl(.parsnip_eng = c("lm","glm"))
fast_regression_parsnip_spec_tbl(.parsnip_eng = c("lm","glm","gee"), 
                                 .parsnip_fns = "linear_reg")
```

As shown we can easily select the models we want either by choosing the supported
`parsnip` function like `linear_reg()` or by choose the desired `engine`, you can 
also use them both in conjunction with each other!

This function also does add a class to the output. Let's see it.
```{r}
class(fast_regression_parsnip_spec_tbl())
```

We see that there are two added classes, first `fst_reg_spec_tbl` because this 
creates a set of non-tuning regression models and then `tidyaml_mod_spec_tbl` because
this is a model specification tibble built with `{tidyaml}`

Now, what if you want to create a non-tuning model spec without using the 
`fast_regression_parsnip_spec_tbl()` function. Well, you can. The function is called
`create_model_spec()`. 

```{r}
create_model_spec(
 .parsnip_eng = list("lm","glm","glmnet","cubist"),
 .parsnip_fns = list(
      rep(
        "linear_reg", 3),
        "cubist_rules"
     )
 )

create_model_spec(
 .parsnip_eng = list("lm","glm","glmnet","cubist"),
 .parsnip_fns = list(
      rep(
        "linear_reg", 3),
        "cubist_rules"
     ),
 .return_tibble = FALSE
 )
```
